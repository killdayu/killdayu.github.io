<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>tips on dayu&#39;s blog</title>
    <link>https://killdayu.com/tags/tips/</link>
    <description>Recent content in tips on dayu&#39;s blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Mon, 06 Jun 2022 12:53:21 +0800</lastBuildDate><atom:link href="https://killdayu.com/tags/tips/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Dingtalk_Location</title>
      <link>https://killdayu.com/posts/dingtalk_location/</link>
      <pubDate>Mon, 06 Jun 2022 12:53:21 +0800</pubDate>
      
      <guid>https://killdayu.com/posts/dingtalk_location/</guid>
      <description>钉钉+某助手配合某框架的通用化在没root的手机上实现远程打卡😋（之前都没想到弄），这样我就不用每天9点起床手动帮别人打卡了。还能配合gayhub上开源的auto. js某脚本实现自动打卡。</description>
    </item>
    
    <item>
      <title>Supercookie</title>
      <link>https://killdayu.com/posts/supercookie/</link>
      <pubDate>Mon, 06 Jun 2022 12:49:21 +0800</pubDate>
      
      <guid>https://killdayu.com/posts/supercookie/</guid>
      <description>我草这个有点🐮，Google翻译看着有点头疼，原理大概就是浏览器会缓存网站的favicon.ico，然后缓存到的favicon.ico再次刷新网页的时候不会重新请求。服务器会在首次访问时创建多个路由（这样才能实现区分多个不同客户端），然后随机将一些路由的favicon.ico设置成200，同时按照路由的favicon.ico生成一个id。客户端再次刷新时由于缓存了某些路由之前的favicon.ico，就只会去请求之前404的favicon.ico，服务器就能得到404的favicon.ico请求然后还原出客户端的id。相当于实现了一个cookie，其实id的实习都源于浏览器的请求，所以代理这些网络层面的都隐藏不了。但是我试了下最新的Chrome失效了😋。但是貌似之前的Firefox中招了，Tor就是魔改的Firefox，也不知道有没有继承缓存favicon.ico这个特性😋，暗网不再暗网😋。一切特征都是supercookie😋。 https://github.com/jonasstrehle/supercookie https://supercookie.me/workwise</description>
    </item>
    
  </channel>
</rss>
